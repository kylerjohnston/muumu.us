---
title: TiddlyWiki user authentication with NGINX auth_requests and Django
date: 2020-11-14
layout: post
excerpt:
tags:
- tiddlywiki
- django
- NGINX
- public-notes
---

In September I created [public-notes.muumu.us](https://public-notes.muumu.us
"public-notes.muumu.us"), a project to create a personal knowledge base
and publish it on the public internet. I chose
[TiddlyWiki](https://tiddlywiki.com/ "TiddlyWiki") for the project for reasons I
outlined in an earlier post, [Building an internet-facing TiddlyWiki for my
public second brain]({% post_url 2020-09-06-building-a-public-tiddlywiki %}
"Building an internet-facing TiddlyWiki for my public second brain - muumu.us").
TiddlyWiki's non-heirarchical approach to note taking is unique and I find its
ergonomics mesh much better with my thought process than a traditional wiki or
something like Evernote. TiddlyWiki is one of a very few pieces of software that
feels completely effortless to use. 

So I chose TiddlyWiki for its great user interface, despite some other
deficiencies that made it a less than ideal choice for the project, like only
supporting HTTP basic authentication. Using public-notes over the past couple
months, the basic auth flow stands out as a real pain point in an otherwise
smooth experience. I use Firefox for a browser and Bitwarden as a password
manager, on both desktop and mobile, and the user experience for getting through
basic auth is frustrating. The basic auth window steals the focus and prevents
you from clicking back into the browser, like you'd need to do to grab your
password from the Bitwarden plugin, so you need to remember to copy the password
*before* navigating to the site --- and since you're not already on the site,
Bitwarden won't autosuggest it and you'll have to search for it. If you forget
to perform that ritual you will have to cancel out of the basic auth window,
perform the rite, and try an incantation of hard refreshes and new private
windows to get the authentication box to reappear --- on the occasional, and
somewhat concerning, refresh the page will simply load without even prompting to
authenticate. On mobile this whole performance is painful enough that I stopped
using it, and the only reason I put the project on the internet to begin with
was to more easily access it via my phone.

There has to be a better way to do this. You will find
[twproxy](https://github.com/stevenleeg/twproxy "stevenleeg/twproxy - GitHub")
suggested as a solution on the TiddlyWiki Google Group. It's a Ruby/Sinatra
application that proxies requests to TiddlyWiki and adds authentication. It
sounded like a good solution, but I ran into a problem described [in an issue on
the project's GitHub](https://github.com/stevenleeg/twproxy/issues/6 "TW
returning 403 on attempted save") where the TiddlyWiki would only render for an
instant before throwing a `Sync error while processing '$:/StoryList'`. I spent
an hour or so starting to fix it last Saturday, but fixing that one bug revealed
another and I started falling down a rabbit hole of trying to fix outdated
dependencies. I became demotivated when I saw there was already a pull request
on the project, open and untouched for three months, that purported to fix the
issue --- although, for what it's worth, I couldn't get that PR's branch working
either, and there are no tests.

Ultimately, twproxy didn't seem like the right approach to me anyway. I already
have NGINX set up as a reverse proxy on TiddlyWiki --- why do I need another
proxy in front of that? After some Googling I found that, using the
`auth_request` module, NGINX will verify each request against an external
authentication server before passing it upstream. The article [Authentication
Based on Subrequest
Result](https://docs.nginx.com/nginx/admin-guide/security-controls/configuring-subrequest-authentication/
"Authentication Based on Subrequest Result - NGINX Plus Admin Guide") from the
NGINX Plus Admin Guide explains it well:

> NGINX and NGINX Plus can authenticate each request to your website with an
> external server or service. To perform authentication, NGINX makes an HTTP
> subrequest to an external server where the subrequest is verified. If the
> subrequest returns a `2xx` response code, the access is allowed, if it returns
> `401` or `403`, the access is denied. Such type of authentication allows
> implementing various authentication schemes, such as multifactor
> authentication, or allows implementing LDAP or OAuth authentication.

That sounds like a good solution, but I still need to find an authentication
service to handle verifying the requests. All of the existing solutions I found
seemed like overkill for my single-user use case --- I didn't want to set up a
Keycloak or a FreeIPA server. Django comes with user management out of the box,
though --- it would be trivial to spin up a small Django app to just validate if
users are logged in by returning a `200` or a `401`, and let them log in if
they're not. So that's what I did.

## Creating your own authentication service with Django

If you've never used Django before, take a look at the official [*Writing your
first Django app*](https://docs.djangoproject.com/en/3.1/intro/tutorial01/
"Writing your first Django app, part 1 - djangoproject.com") series.

The template project created by `django-admin startproject` has, on its own,
*almost* everything that's needed to work as an authentication service for NGINX
`auth_request`. I called my project `is_authenticated`. Running `django-admin
startproject is_authenticated` generates these directories and files:

```
is_authenticated/
├── is_authenticated
│   ├── asgi.py
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── manage.py
```

The first thing we need to do is add a view to validate if a user is logged in or not. If the user is logged in, it will return a `200` HTTP response code. If the user is not logged in, it will return a `401` HTTP response code.

In a new file `is_authenticated/is_authenticated/views.py`:

```python
from django.http import HttpResponse

def is_authenticated(request):
    if request.user.is_authenticated:
        return HttpResponse('Signed in')
    else:
        return HttpResponse('Not signed in!', status=401)
```

That is the main business logic of our little app. Now we need to associate a
URL pattern with that view. Open `is_authenticated/is_authenticated/urls.py`. Import the `views.py` file you created, and add a URL pattern to associated to `views.is_authenticated`. In my case, I chose `auth/`.

```python
from django.contrib import admin
from django.urls import path, include

from . import views

urlpatterns = [
    path('admin/', admin.site.urls),
    path('auth/', views.is_authenticated, name='is_authenticated')
]
```

We're mostly done --- we just need a way for users to sign in. Django
mostly handles this for us using [its built-in authentication
views](https://docs.djangoproject.com/en/3.1/topics/auth/default/#module-django.contrib.auth.views
"Authentication Views - Django Project"). Add one more URL pattern to `urls.py`
to set them up:

```python
urlpatterns = [
    path('admin/', admin.site.urls),
    path('auth/', views.is_authenticated, name='is_authenticated'),
    path('accounts/', include('django.contrib.auth.urls'))
]
```

This will let users log in by going to `/accounts/login/` --- it will also
enable a few other endpoints for logging out and changing passwords, but we can
ignore those for now. The last thing we need to do to get `/accounts/login/`
working is to create a template for it. First, define a template directory in
`is_authenticated/is_authenticated/settings.py`. I set it to
`is_authenticated/templates/`.

```python
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```

Now, create a basic template for the login page in
`is_authenticated/templates/registration/login.html`. I just slightly modified
Django's example login template.

{% raw %}
```html
<html>
    <body>
        {% if form.errors %}
        <p>Your username and password didn't match. Please try again.</p>
        {% endif %}

        {% if next %}
        {% if user.is_authenticated %}
        <p>Your account doesn't have access to this page. To proceed,
            please login with an account that has access.</p>
        {% else %}
        <p>Please login to see this page.</p>
        {% endif %}
        {% endif %}

        <form method="post" action="{% url 'login' %}">
            {% csrf_token %}
            <table>
                <tr>
                    <td>{{ form.username.label_tag }}</td>
                    <td>{{ form.username }}</td>
                </tr>
                <tr>
                    <td>{{ form.password.label_tag }}</td>
                    <td>{{ form.password }}</td>
                </tr>
            </table>

            <input type="submit" value="login">
            <input type="hidden" name="next" value="{{ next }}">
        </form>
    </body>
</html>
```
{% endraw %}

At this point the app will work, but you'll get a Django error page after
logging in because it tries to redirect you to a view you haven't made a
template for. I don't want to make another template --- if the login is
successful, I want to be redirected to my TiddlyWiki. You can open
`is_authenticated/is_authenticated/settings.py` again and hardcode

```python
LOGIN_REDIRECT_URL = 'https://your-tiddlywiki.com'
LOGOUT_REDIRECT_URL = 'https://your-tiddlywiki.com'
```

And now you have a functioning, all be it basic, authentication service. Run
`manage.py migrate` and `manage.py createsuperuser` to create the SQLite
database and add an admin user. You can login at `/accounts/login/` using the
admin credentials, or you can create new users from the Django admin console by
navigating to `/admin/`.

You can see the full version of the app I made [on
GitHub](https://github.com/kylerjohnston/is_authenticated
"kylerjohnston/is_authenticated - GitHub").

## Deploying and running the authentication service

In [*Building an internet-facing TiddlyWiki for my public second brain*]({%
post_url 2020-09-06-building-a-public-tiddlywiki %} "Building an internet-facing
TiddlyWiki for my public second brain") I wrote about why I chose PM2 to manage
the TiddlyWiki process. I'm deploying the authentication service on the same
server as TiddlyWiki, so I'm using PM2 to it service as well. You could use
other process management utilities like systemd or supervisord.

Deployment is simple: clone the repository, with permissions such that the
directory belongs to your application user, create a Python virtual environment
for the app, and install the application's dependencies into the virutal
environment:

```bash
$ sudo mkdir /srv/is_authenticated
$ sudo chown -R appuser:appuser /srv/is_authenticated
$ git clone git@github.com:kylerjohnston/is_authenticated.git \
  /srv/is_authenticated
$ cd /srv/is_authenticated
$ python3 -m venv venv/
$ source venv/bin/activate
(venv) $ pip install -r requirements.txt
```

If you are using my `is_authenticated` app, you need to set some environment
variables --- we hardcoded these values into the example app above. Edit
`/srv/is_authenticated/env.sh` to look like this:

```bash
#!/usr/bin/env bash

# The login page is https://my-tiddly-domain.com/accounts/login;
# this will redirect successful logins to https://my-tiddly-domain.com/
# This is the value for `LOGIN_REDIRECT_URL` and `LOGOUT_REDIRECT_URL`
# we defined above; I pulled it into an environment variable in my app
export REDIRECT_URL='/'

# This is the value that was in `is_authenticated/settings.py`
# as `SECRET_KEY`; I pulled it into an environment variable
# in my version of the app
export SECRET_KEY='your django secret key'
```

I wrote a shell script to start the server and installed it to `/srv/is_authenticated/start_server.sh`:

```bash
#!/usr/bin/env bash

source /srv/is_authenticated/env.sh
source /srv/is_authenticated/venv/bin/activate
cd /srv/is_authenticated/is_authenticated && \
  gunicorn is_authenticated.wsgi --bind 127.0.0.1:8000 --workers 1
```

Note that I bind to `127.0.0.1` --- the server will only accept connections from
its own host --- all requests to the authentication server will have to go
through the NGINX reverse proxy on the same host.

If you run `/srv/is_authenticated/start_server.sh` now, your authentication
service will be running on port 8000. I'm going to run it with PM2 for better
monitoring and so it starts automatically.

```bash
pm2 start /srv/is_authenticated/start_server.sh
pm2 dump
```

`pm2 dump` will write my current PM2 state --- running `is_authenticated` and TiddlyWiki --- to disk. Running `pm2 resurrect` will start PM2 with that same state --- I have a systemd unit file set up to do this, so my services start back up on boot or restart.

## Configuring NGINX

So now I have TiddlyWiki running on port 8080 and the authentication service running on port 8000 on the same host. All we need to do at this point is configure NGINX.

First, let's add location blocks for the authentication service. The authentication service has two endpoints: `/auth/`, the main application, returns `200` if the user is authenticated and `401` if not; `/accounts/login/` is the user log in page.

```
location = /auth/ {
    internal;
    proxy_pass   http://127.0.0.1:8000;
    proxy_pass_request_body off;
    proxy_set_header Content-Length "";
    proxy_set_header X-Original-URI $request_uri;
}

location = /accounts/login/ {
    proxy_pass  http://127.0.0.1:8000/accounts/login/;
}
```

The `internal` keyword tells NGINX this endpoint is not accessible to external
requests --- a user trying to navigate to
https://my-tiddly-wiki-domain.com/auth/ will get a `404`; only our NGINX proxy
can send requests there.

I also drop the request body because the authentication service doesn't need
that data. The `X-Original-URI` header isn't really needed at this point, but
I'm passing it along here because in a future version of the authentication
service I'd like to have it use that header to redirect after a succesful log
in.

Now we have to update the location block for TiddlyWiki to use the
`auth_request` module.

```
location / {
    error_page 401 = @error401;
    auth_request    /auth/;
    proxy_pass http://127.0.0.1:8080;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
}
```

I only added two lines here: `auth_request /auth/;` tells NGINX that for each
request to this location it should send a subrequest to `/auth/` to verify
if the user is authenticated.

The `error_page` keyword sets a URI to be presented in the case of an error. In
this case, I'm setting NGINX to direct requests to the named location
`@error401` in the event that a request to this location returns a `401`
response --- i.e., if the user is not authenticated. Let's define the
`@error401` location:

```
location @error401 {
    return 302 https://$host/accounts/login/;
}
```

This means in the event of a `401`, we will redirect users to the log in page.
